import { camelCase } from 'lodash'
import * as prettier from 'prettier'
import fs from 'fs'
import z from 'zod'
import {
  CreateRequestPayload,
  CreateResponsePayload,
  PropMapping,
} from '../connect/parser_executable_types'
import path from 'path'
import { normalizeComponentName } from '../connect/create'

function isBooleanKind(propValue: string) {
  const normalized = propValue.toLowerCase()
  return (
    normalized === 'true' ||
    normalized === 'false' ||
    normalized === 'yes' ||
    normalized === 'no' ||
    normalized === 'on' ||
    normalized === 'off'
  )
}

function normalizePropName(name: string) {
  return name.replace(/#[0-9:]*/g, '')
}

function generateCodePropName(name: string) {
  return camelCase(name.replace(/[^a-zA-Z0-9]/g, ''))
}

function normalizePropValue(name: string) {
  // Convert the string to kebab-case
  return name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()
}

function generateProps(component: CreateRequestPayload['component'], propMapping?: PropMapping) {
  const props: string[] = []
  if (
    !component.componentPropertyDefinitions ||
    Object.keys(component.componentPropertyDefinitions).length === 0
  ) {
    return `{}`
  }

  for (const [propName, propDef] of Object.entries(component.componentPropertyDefinitions)) {
    const mappedProp = propMapping && propMapping[propName]
    const codePropName = mappedProp ? mappedProp.codePropName : generateCodePropName(propName)
    const type = mappedProp ? mappedProp.mapping : propDef.type
    const figmaPropName = normalizePropName(propName)

    if (type === 'BOOLEAN') {
      props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
    }
    if (type === 'TEXT') {
      props.push(`"${codePropName}": figma.string('${figmaPropName}')`)
    }
    if (type === 'VARIANT') {
      const isBooleanVariant =
        propDef.variantOptions?.length === 2 && propDef.variantOptions.every(isBooleanKind)
      if (isBooleanVariant) {
        props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
      } else {
        props.push(
          `"${codePropName}": figma.enum('${figmaPropName}', { \n${propDef.variantOptions
            ?.map((value) => `  "${value}": "${normalizePropValue(value)}"`)
            .join(',\n')}})`,
        )
      }
    }
    if (type === 'INSTANCE_SWAP') {
      props.push(`"${codePropName}": figma.instance('${figmaPropName}')`)
    }
  }
  return `{
  ${props.join(',\n  ')}
}`
}

function getOutFileName({
  outFile,
  outDir,
  sourceFilename,
}: {
  outFile: string | undefined
  outDir: string
  sourceFilename: string
}): string {
  if (outFile) {
    return outFile
  }

  const baseName = `${sourceFilename}.figma.tsx`

  if (outDir) {
    return path.join(outDir, baseName)
  }

  return path.join(process.env.INIT_CWD ?? process.cwd(), baseName)
}

// returns ES-style import path from given system path
function formatImportPath(systemPath: string) {
  // use forward slashes for import paths
  let formattedImportPath = systemPath.replaceAll(path.sep, '/')

  // prefix current dir paths with ./ (node path does not)
  if (!formattedImportPath.startsWith('.')) {
    formattedImportPath = `./${formattedImportPath}`
  }

  // assume not using ESM imports
  return formattedImportPath.replace(/\.(jsx|tsx)$/, '')
}

function getImportsPath({
  codeConnectFilePath,
  sourceFilepath,
  normalizedName,
}: {
  codeConnectFilePath: string
  sourceFilepath?: string
  normalizedName: string
}) {
  if (!sourceFilepath) {
    return `./${normalizedName}`
  }
  const codeConnectFolder = path.dirname(codeConnectFilePath)
  const pathToComponentFile = path.relative(codeConnectFolder, sourceFilepath)

  return formatImportPath(pathToComponentFile)
}

export async function createReactCodeConnect(
  payload: CreateRequestPayload,
): Promise<z.infer<typeof CreateResponsePayload>> {
  const { component, destinationFile, destinationDir, sourceFilepath, sourceExport, propMapping } =
    payload
  const { normalizedName, figmaNodeUrl } = component

  const sourceFilename = sourceFilepath
    ? path.parse(sourceFilepath).name.split('.')[0]
    : normalizedName

  const filePath = getOutFileName({
    outFile: destinationFile,
    outDir: destinationDir,
    sourceFilename,
  })

  const importsPath = getImportsPath({
    codeConnectFilePath: filePath,
    sourceFilepath,
    normalizedName,
  })

  const importName =
    sourceFilepath && sourceExport
      ? sourceExport === 'default'
        ? normalizeComponentName(sourceFilename)
        : sourceExport
      : normalizedName

  const codeConnect = `
import React from 'react'
import ${sourceExport === 'default' ? importName : `{ ${importName} }`} from '${importsPath}'
import figma from '@figma/code-connect'

/**
 * -- This file was auto-generated by \`figma connect create\` --
 * \`props\` includes a mapping from Figma properties and variants to
 * suggested values. You should update this to match the props of your
 * code component, and update the \`example\` function to return the
 * code example you'd like to see in Figma
*/

figma.connect(${importName}, "${figmaNodeUrl}", {
  props: ${generateProps(component, propMapping)},
  example: (props) => <${importName} />
})
`
  let formatted = await prettier.format(codeConnect, {
    parser: 'typescript',
    semi: false,
    trailingComma: 'all',
  })

  if (fs.existsSync(filePath)) {
    return {
      createdFiles: [],
      messages: [{ message: `File ${filePath} already exists, skipping creation`, level: 'ERROR' }],
    }
  }
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
  fs.writeFileSync(filePath, formatted)

  return { createdFiles: [{ filePath }], messages: [] }
}
