import { camelCase } from 'lodash'
import * as prettier from 'prettier'
import fs from 'fs'
import z from 'zod'
import { CreateRequestPayload, CreateResponsePayload } from '../connect/parser_executable_types'
import path from 'path'

function isBooleanKind(propValue: string) {
  const normalized = propValue.toLowerCase()
  return (
    normalized === 'true' ||
    normalized === 'false' ||
    normalized === 'yes' ||
    normalized === 'no' ||
    normalized === 'on' ||
    normalized === 'off'
  )
}

function normalizePropName(name: string) {
  return name.replace(/#[0-9:]*/g, '')
}

function generateCodePropName(name: string) {
  return camelCase(name.replace(/[^a-zA-Z]/g, ''))
}

function normalizePropValue(name: string) {
  // Convert the string to kebab-case
  return name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()
}

function generateProps(component: CreateRequestPayload['component']) {
  const props: string[] = []
  if (
    !component.componentPropertyDefinitions ||
    Object.keys(component.componentPropertyDefinitions).length === 0
  ) {
    return `{}`
  }

  for (const [propName, propDef] of Object.entries(component.componentPropertyDefinitions)) {
    const codePropName = generateCodePropName(propName)
    const figmaPropName = normalizePropName(propName)
    if (propDef.type === 'BOOLEAN') {
      props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
    }
    if (propDef.type === 'TEXT') {
      props.push(`"${codePropName}": figma.string('${figmaPropName}')`)
    }
    if (propDef.type === 'VARIANT') {
      if (propDef.variantOptions?.find((value) => isBooleanKind(value))) {
        props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
      } else {
        props.push(
          `"${codePropName}": figma.enum('${figmaPropName}', { \n${propDef.variantOptions
            ?.map((value) => `  "${value}": "${normalizePropValue(value)}"`)
            .join(',\n')}})`,
        )
      }
    }
    if (propDef.type === 'INSTANCE_SWAP') {
      props.push(`"${codePropName}": figma.instance('${figmaPropName}')`)
    }
  }
  return `{
  ${props.join(',\n  ')}
}`
}

function getOutFileName({
  outFile,
  outDir,
  componentName,
}: {
  outFile: string | undefined
  outDir: string
  componentName: string
}): string {
  if (outFile) {
    return outFile
  }

  const baseName = `${componentName}.figma.tsx`

  if (outDir) {
    return path.join(outDir, baseName)
  }

  return path.join(process.env.INIT_CWD ?? process.cwd(), baseName)
}

export async function createReactCodeConnect(
  payload: CreateRequestPayload,
): Promise<z.infer<typeof CreateResponsePayload>> {
  const { component, destinationFile, destinationDir } = payload
  const { normalizedName, figmaNodeUrl } = component
  const filePath = getOutFileName({
    outFile: destinationFile,
    outDir: destinationDir,
    componentName: normalizedName,
  })

  const codeConnect = `
import React from 'react'
import { ${normalizedName} } from './${normalizedName}'
import figma from '@figma/code-connect'

/**
 * -- This file was auto-generated by \`figma connect create\` --
 * \`props\` includes a mapping from Figma properties and variants to
 * suggested values. You should update this to match the props of your
 * code component, and update the \`example\` function to return the
 * code example you'd like to see in Figma
*/

figma.connect(${normalizedName}, "${figmaNodeUrl}", {
  props: ${generateProps(component)},
  example: (props) => <${normalizedName} />
})
`
  let formatted = await prettier.format(codeConnect, {
    parser: 'typescript',
    semi: false,
    trailingComma: 'all',
  })

  if (fs.existsSync(filePath)) {
    return {
      createdFiles: [],
      messages: [{ message: `File ${filePath} already exists, skipping creation`, level: 'ERROR' }],
    }
  }
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
  fs.writeFileSync(filePath, formatted)

  return { createdFiles: [{ filePath }], messages: [] }
}
